#!/bin/bash

# Colors for better readability
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Print usage info
function show_usage {
    echo -e "${YELLOW}Usage: dbrun <filename> [options]${NC}"
    echo "    filename: C++ file name without .cpp extension"
    echo "Options:"
    echo "    -t: Show execution time"
    echo "    -m: Show memory usage"
    echo "    -d: Debug mode (compile with debug flags)"
    exit 1
}

# Check if a filename is provided
if [ $# -eq 0 ]; then
    echo -e "${RED}❌ Error: No C++ file provided!${NC}"
    show_usage
fi

# Parse arguments
FILENAME="$1"
SHOW_TIME=false
SHOW_MEMORY=false
DEBUG_MODE=false

shift
while getopts "tmd" opt; do
    case $opt in
        t) SHOW_TIME=true ;;
        m) SHOW_MEMORY=true ;;
        d) DEBUG_MODE=true ;;
        *) show_usage ;;
    esac
done

FILE="${FILENAME}.cpp"  # Add .cpp extension
EXECUTABLE="${FILENAME}"  # Executable name

# Verify source file exists
if [ ! -f "$FILE" ]; then
    echo -e "${RED}❌ Error: File '$FILE' not found!${NC}"
    exit 1
fi

# Verify input/output files
if [ ! -f "input.txt" ]; then
    echo -e "${RED}❌ Error: input.txt not found!${NC}"
    exit 1
fi

if [ ! -f "output.txt" ]; then
    echo -e "${RED}❌ Error: output.txt not found!${NC}"
    exit 1
fi

# Set compilation flags
if [ "$DEBUG_MODE" = true ]; then
    COMPILE_FLAGS="-std=c++17 -Wall -Wextra -g -DDEBUG -fsanitize=address,undefined"
else
    COMPILE_FLAGS="-std=c++17 -Wall -Wextra -O2"
fi

# Compile the C++ file
echo -e "${BLUE}Compiling $FILE...${NC}"
g++ $COMPILE_FLAGS "$FILE" -o "$EXECUTABLE"

if [ $? -ne 0 ]; then
    echo -e "${RED}❌ Compilation Error!${NC}"
    exit 1
fi
echo -e "${GREEN}✅ Compilation successful${NC}"

# Create a temporary file for program's output
MY_OUTPUT="my_output.txt"

# Run the program with input redirection and measure time
echo -e "${BLUE}Running program...${NC}"

if [ "$SHOW_TIME" = true ]; then
    START_TIME=$(date +%s.%N)
    time ./"$EXECUTABLE" < input.txt > "$MY_OUTPUT"
    END_TIME=$(date +%s.%N)
    ELAPSED_TIME=$(echo "$END_TIME - $START_TIME" | bc)
    echo -e "${YELLOW}Execution time: ${ELAPSED_TIME} seconds${NC}"
elif [ "$SHOW_MEMORY" = true ]; then
    /usr/bin/time -v ./"$EXECUTABLE" < input.txt > "$MY_OUTPUT" 2> memory_info.txt
    MAX_MEMORY=$(grep "Maximum resident set size" memory_info.txt | awk '{print $6}')
    echo -e "${YELLOW}Peak memory usage: $MAX_MEMORY KB${NC}"
    rm memory_info.txt
else
    ./"$EXECUTABLE" < input.txt > "$MY_OUTPUT"
fi

# Check if outputs match, ignoring whitespace differences
if diff -Z "$MY_OUTPUT" output.txt > /dev/null; then
    echo -e "${GREEN}✅ Accepted${NC}"
else
    echo -e "${RED}❌ Wrong Answer${NC}"
    
    # Count number of lines in both files to determine test cases
    expected_lines=$(wc -l < output.txt)
    actual_lines=$(wc -l < "$MY_OUTPUT")
    
    # Try to determine number of test cases
    # Assuming first line of input contains the number of test cases
    num_tests=$(head -n 1 input.txt | tr -d '[:space:]')
    if ! [[ "$num_tests" =~ ^[0-9]+$ ]]; then
        # If not a number, estimate based on output lines
        num_tests=$(( (expected_lines + actual_lines) / 4 ))  # Rough estimate
        if [ "$num_tests" -lt 1 ]; then num_tests=1; fi
    fi
    
    # Process line by line comparison with test case headers
    echo ""
    test_case=1
    expected_line=1
    actual_line=1
    
    while [ "$test_case" -le "$num_tests" ] && [ "$expected_line" -le "$expected_lines" ] && [ "$actual_line" -le "$actual_lines" ]; do
        echo -e "${CYAN}#Case $test_case${NC}"
        
        # Get current expected line
        expected=$(sed -n "${expected_line}p" output.txt)
        expected_line=$((expected_line + 1))
        
        # Get current actual line
        actual=$(sed -n "${actual_line}p" "$MY_OUTPUT")
        actual_line=$((actual_line + 1))
        
        # Display comparison with appropriate colors
        echo -e "${GREEN}Expected: $expected${NC}"
        
        # Use GREEN for matching output, RED for non-matching
        if [ "$expected" = "$actual" ]; then
            echo -e "${GREEN}Your output: $actual${NC}"
            echo -e "${GREEN}✓ This line matches${NC}"
        else
            echo -e "${RED}Your output: $actual${NC}"
            # No detailed character-by-character differences
        fi
        
        echo ""
        test_case=$((test_case + 1))
    done
    
    # Report if there are extra or missing lines
    if [ "$expected_line" -le "$expected_lines" ]; then
        echo -e "${RED}Missing output lines:${NC}"
        tail -n +$expected_line output.txt | while read -r line; do
            echo -e "${GREEN}Expected: $line${NC}"
        done
    elif [ "$actual_line" -le "$actual_lines" ]; then
        echo -e "${RED}Extra output lines:${NC}"
        tail -n +$actual_line "$MY_OUTPUT" | while read -r line; do
            echo -e "${RED}Your output: $line${NC}"
        done
    fi
fi

# Clean up
rm -f "$MY_OUTPUT"
rm -f "$EXECUTABLE"

echo -e "${BLUE}Test completed${NC}"